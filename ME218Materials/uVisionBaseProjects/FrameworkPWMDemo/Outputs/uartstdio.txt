; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\outputs\uartstdio.o --asm_dir=.\Outputs\ --list_dir=.\Outputs\ --depend=.\outputs\uartstdio.d --cpu=Cortex-M4.fp --apcs=interwork -IC:\ti\TivaWare_C_Series-2.1.0.12573 -I.\Headers -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.0.0\Device\Include\TM4C123 -DTM4C123GH6PM -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RB1 --omf_browse=.\outputs\uartstdio.crf Source\uartstdio.c]
                          THUMB

                          AREA ||i.UARTStdioConfig||, CODE, READONLY, ALIGN=2

                  UARTStdioConfig PROC
;;;333    void
;;;334    UARTStdioConfig(uint32_t ui32PortNum, uint32_t ui32Baud, uint32_t ui32SrcClock)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;335    {
;;;336        //
;;;337        // Check the arguments.
;;;338        //
;;;339        ASSERT((ui32PortNum == 0) || (ui32PortNum == 1) ||
;;;340               (ui32PortNum == 2));
;;;341    
;;;342    #ifdef UART_BUFFERED
;;;343        //
;;;344        // In buffered mode, we only allow a single instance to be opened.
;;;345        //
;;;346        ASSERT(g_ui32Base == 0);
;;;347    #endif
;;;348    
;;;349        //
;;;350        // Check to make sure the UART peripheral is present.
;;;351        //
;;;352        if(!MAP_SysCtlPeripheralPresent(g_ui32UARTPeriph[ui32PortNum]))
000004  f04f7580          MOV      r5,#0x1000000
000008  4689              MOV      r9,r1                 ;335
00000a  6c69              LDR      r1,[r5,#0x44]
00000c  4f11              LDR      r7,|L1.84|
00000e  4604              MOV      r4,r0                 ;335
000010  6909              LDR      r1,[r1,#0x10]
000012  4690              MOV      r8,r2                 ;335
000014  f8570024          LDR      r0,[r7,r4,LSL #2]
000018  4788              BLX      r1
00001a  2800              CMP      r0,#0
00001c  d017              BEQ      |L1.78|
;;;353        {
;;;354            return;
;;;355        }
;;;356    
;;;357        //
;;;358        // Select the base address of the UART.
;;;359        //
;;;360        g_ui32Base = g_ui32UARTBase[ui32PortNum];
00001e  f1a7000c          SUB      r0,r7,#0xc
000022  4e0d              LDR      r6,|L1.88|
000024  f8500024          LDR      r0,[r0,r4,LSL #2]
;;;361    
;;;362        //
;;;363        // Enable the UART peripheral for use.
;;;364        //
;;;365        MAP_SysCtlPeripheralEnable(g_ui32UARTPeriph[ui32PortNum]);
000028  6070              STR      r0,[r6,#4]  ; g_ui32Base
00002a  6c69              LDR      r1,[r5,#0x44]
00002c  f8570024          LDR      r0,[r7,r4,LSL #2]
000030  6989              LDR      r1,[r1,#0x18]
000032  4788              BLX      r1
;;;366    
;;;367        //
;;;368        // Configure the UART for 115200, n, 8, 1
;;;369        //
;;;370        MAP_UARTConfigSetExpClk(g_ui32Base, ui32SrcClock, ui32Baud,
000034  6968              LDR      r0,[r5,#0x14]
000036  2360              MOVS     r3,#0x60
000038  464a              MOV      r2,r9
00003a  6944              LDR      r4,[r0,#0x14]
00003c  4641              MOV      r1,r8
00003e  6870              LDR      r0,[r6,#4]  ; g_ui32Base
000040  47a0              BLX      r4
;;;371                                (UART_CONFIG_PAR_NONE | UART_CONFIG_STOP_ONE |
;;;372                                 UART_CONFIG_WLEN_8));
;;;373    
;;;374    #ifdef UART_BUFFERED
;;;375        //
;;;376        // Set the UART to interrupt whenever the TX FIFO is almost empty or
;;;377        // when any character is received.
;;;378        //
;;;379        MAP_UARTFIFOLevelSet(g_ui32Base, UART_FIFO_TX1_8, UART_FIFO_RX1_8);
;;;380    
;;;381        //
;;;382        // Flush both the buffers.
;;;383        //
;;;384        UARTFlushRx();
;;;385        UARTFlushTx(true);
;;;386    
;;;387        //
;;;388        // Remember which interrupt we are dealing with.
;;;389        //
;;;390        g_ui32PortNum = ui32PortNum;
;;;391    
;;;392        //
;;;393        // We are configured for buffered output so enable the master interrupt
;;;394        // for this UART and the receive interrupts.  We don't actually enable the
;;;395        // transmit interrupt in the UART itself until some data has been placed
;;;396        // in the transmit buffer.
;;;397        //
;;;398        MAP_UARTIntDisable(g_ui32Base, 0xFFFFFFFF);
;;;399        MAP_UARTIntEnable(g_ui32Base, UART_INT_RX | UART_INT_RT);
;;;400        MAP_IntEnable(g_ui32UARTInt[ui32PortNum]);
;;;401    #endif
;;;402    
;;;403        //
;;;404        // Enable the UART operation.
;;;405        //
;;;406        MAP_UARTEnable(g_ui32Base);
000042  6968              LDR      r0,[r5,#0x14]
000044  69c1              LDR      r1,[r0,#0x1c]
000046  6870              LDR      r0,[r6,#4]  ; g_ui32Base
000048  e8bd47f0          POP      {r4-r10,lr}
00004c  4708              BX       r1
                  |L1.78|
;;;407    }
00004e  e8bd87f0          POP      {r4-r10,pc}
;;;408    
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      ||.constdata||+0x10
                  |L1.88|
                          DCD      ||.data||

                          AREA ||i.UARTgetc||, CODE, READONLY, ALIGN=2

                  UARTgetc PROC
;;;785    unsigned char
;;;786    UARTgetc(void)
000000  b510              PUSH     {r4,lr}
;;;787    {
;;;788    #ifdef UART_BUFFERED
;;;789        unsigned char cChar;
;;;790    
;;;791        //
;;;792        // Wait for a character to be received.
;;;793        //
;;;794        while(RX_BUFFER_EMPTY)
;;;795        {
;;;796            //
;;;797            // Block waiting for a character to be received (if the buffer is
;;;798            // currently empty).
;;;799            //
;;;800        }
;;;801    
;;;802        //
;;;803        // Read a character from the buffer.
;;;804        //
;;;805        cChar = g_pcUARTRxBuffer[g_ui32UARTRxReadIndex];
;;;806        ADVANCE_RX_BUFFER_INDEX(g_ui32UARTRxReadIndex);
;;;807    
;;;808        //
;;;809        // Return the character to the caller.
;;;810        //
;;;811        return(cChar);
;;;812    #else
;;;813        //
;;;814        // Block until a character is received by the UART then return it to
;;;815        // the caller.
;;;816        //
;;;817        return(MAP_UARTCharGet(g_ui32Base));
000002  f04f7080          MOV      r0,#0x1000000
000006  6940              LDR      r0,[r0,#0x14]
000008  6b81              LDR      r1,[r0,#0x38]
00000a  4802              LDR      r0,|L2.20|
00000c  6840              LDR      r0,[r0,#4]  ; g_ui32Base
00000e  4788              BLX      r1
000010  b2c0              UXTB     r0,r0
;;;818    #endif
;;;819    }
000012  bd10              POP      {r4,pc}
;;;820    
                          ENDP

                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.UARTgets||, CODE, READONLY, ALIGN=2

                  UARTgets PROC
;;;568    int
;;;569    UARTgets(char *pcBuf, uint32_t ui32Len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;570    {
;;;571    #ifdef UART_BUFFERED
;;;572        uint32_t ui32Count = 0;
;;;573        int8_t cChar;
;;;574    
;;;575        //
;;;576        // Check the arguments.
;;;577        //
;;;578        ASSERT(pcBuf != 0);
;;;579        ASSERT(ui32Len != 0);
;;;580        ASSERT(g_ui32Base != 0);
;;;581    
;;;582        //
;;;583        // Adjust the length back by 1 to leave space for the trailing
;;;584        // null terminator.
;;;585        //
;;;586        ui32Len--;
;;;587    
;;;588        //
;;;589        // Process characters until a newline is received.
;;;590        //
;;;591        while(1)
;;;592        {
;;;593            //
;;;594            // Read the next character from the receive buffer.
;;;595            //
;;;596            if(!RX_BUFFER_EMPTY)
;;;597            {
;;;598                cChar = g_pcUARTRxBuffer[g_ui32UARTRxReadIndex];
;;;599                ADVANCE_RX_BUFFER_INDEX(g_ui32UARTRxReadIndex);
;;;600    
;;;601                //
;;;602                // See if a newline or escape character was received.
;;;603                //
;;;604                if((cChar == '\r') || (cChar == '\n') || (cChar == 0x1b))
;;;605                {
;;;606                    //
;;;607                    // Stop processing the input and end the line.
;;;608                    //
;;;609                    break;
;;;610                }
;;;611    
;;;612                //
;;;613                // Process the received character as long as we are not at the end
;;;614                // of the buffer.  If the end of the buffer has been reached then
;;;615                // all additional characters are ignored until a newline is
;;;616                // received.
;;;617                //
;;;618                if(ui32Count < ui32Len)
;;;619                {
;;;620                    //
;;;621                    // Store the character in the caller supplied buffer.
;;;622                    //
;;;623                    pcBuf[ui32Count] = cChar;
;;;624    
;;;625                    //
;;;626                    // Increment the count of characters received.
;;;627                    //
;;;628                    ui32Count++;
;;;629                }
;;;630            }
;;;631        }
;;;632    
;;;633        //
;;;634        // Add a null termination to the string.
;;;635        //
;;;636        pcBuf[ui32Count] = 0;
;;;637    
;;;638        //
;;;639        // Return the count of int8_ts in the buffer, not counting the trailing 0.
;;;640        //
;;;641        return(ui32Count);
;;;642    #else
;;;643        uint32_t ui32Count = 0;
000004  2400              MOVS     r4,#0
;;;644        int8_t cChar;
;;;645        static int8_t bLastWasCR = 0;
;;;646    
;;;647        //
;;;648        // Check the arguments.
;;;649        //
;;;650        ASSERT(pcBuf != 0);
;;;651        ASSERT(ui32Len != 0);
;;;652        ASSERT(g_ui32Base != 0);
;;;653    
;;;654        //
;;;655        // Adjust the length back by 1 to leave space for the trailing
;;;656        // null terminator.
;;;657        //
;;;658        ui32Len--;
;;;659    
;;;660        //
;;;661        // Process characters until a newline is received.
;;;662        //
;;;663        while(1)
;;;664        {
;;;665            //
;;;666            // Read the next character from the console.
;;;667            //
;;;668            cChar = MAP_UARTCharGet(g_ui32Base);
000006  4d1c              LDR      r5,|L3.120|
000008  4680              MOV      r8,r0                 ;570
00000a  1e4f              SUBS     r7,r1,#1              ;643
00000c  46a1              MOV      r9,r4                 ;643
00000e  f04f7680          MOV      r6,#0x1000000
                  |L3.18|
000012  6970              LDR      r0,[r6,#0x14]
000014  6b81              LDR      r1,[r0,#0x38]
000016  6868              LDR      r0,[r5,#4]  ; g_ui32Base
000018  4788              BLX      r1
00001a  b240              SXTB     r0,r0
;;;669    
;;;670            //
;;;671            // See if the backspace key was pressed.
;;;672            //
;;;673            if(cChar == '\b')
00001c  2808              CMP      r0,#8
00001e  d012              BEQ      |L3.70|
;;;674            {
;;;675                //
;;;676                // If there are any characters already in the buffer, then delete
;;;677                // the last.
;;;678                //
;;;679                if(ui32Count)
;;;680                {
;;;681                    //
;;;682                    // Rub out the previous character.
;;;683                    //
;;;684                    UARTwrite("\b \b", 3);
;;;685    
;;;686                    //
;;;687                    // Decrement the number of characters in the buffer.
;;;688                    //
;;;689                    ui32Count--;
;;;690                }
;;;691    
;;;692                //
;;;693                // Skip ahead to read the next character.
;;;694                //
;;;695                continue;
;;;696            }
;;;697    
;;;698            //
;;;699            // If this character is LF and last was CR, then just gobble up the
;;;700            // character because the EOL processing was taken care of with the CR.
;;;701            //
;;;702            if((cChar == '\n') && bLastWasCR)
000020  280a              CMP      r0,#0xa
000022  d018              BEQ      |L3.86|
;;;703            {
;;;704                bLastWasCR = 0;
;;;705                continue;
;;;706            }
;;;707    
;;;708            //
;;;709            // See if a newline or escape character was received.
;;;710            //
;;;711            if((cChar == '\r') || (cChar == '\n') || (cChar == 0x1b))
000024  280d              CMP      r0,#0xd
000026  d01b              BEQ      |L3.96|
000028  280a              CMP      r0,#0xa
00002a  d01b              BEQ      |L3.100|
00002c  281b              CMP      r0,#0x1b
00002e  d019              BEQ      |L3.100|
;;;712            {
;;;713                //
;;;714                // If the character is a CR, then it may be followed by a LF which
;;;715                // should be paired with the CR.  So remember that a CR was
;;;716                // received.
;;;717                //
;;;718                if(cChar == '\r')
;;;719                {
;;;720                    bLastWasCR = 1;
;;;721                }
;;;722    
;;;723                //
;;;724                // Stop processing the input and end the line.
;;;725                //
;;;726                break;
;;;727            }
;;;728    
;;;729            //
;;;730            // Process the received character as long as we are not at the end of
;;;731            // the buffer.  If the end of the buffer has been reached then all
;;;732            // additional characters are ignored until a newline is received.
;;;733            //
;;;734            if(ui32Count < ui32Len)
000030  42bc              CMP      r4,r7
000032  d2ee              BCS      |L3.18|
;;;735            {
;;;736                //
;;;737                // Store the character in the caller supplied buffer.
;;;738                //
;;;739                pcBuf[ui32Count] = cChar;
000034  b2c1              UXTB     r1,r0
000036  f8081004          STRB     r1,[r8,r4]
;;;740    
;;;741                //
;;;742                // Increment the count of characters received.
;;;743                //
;;;744                ui32Count++;
;;;745    
;;;746                //
;;;747                // Reflect the character back to the user.
;;;748                //
;;;749                MAP_UARTCharPut(g_ui32Base, cChar);
00003a  6970              LDR      r0,[r6,#0x14]
00003c  1c64              ADDS     r4,r4,#1
00003e  6802              LDR      r2,[r0,#0]
000040  6868              LDR      r0,[r5,#4]  ; g_ui32Base
000042  4790              BLX      r2
000044  e7e5              B        |L3.18|
                  |L3.70|
000046  2c00              CMP      r4,#0                 ;679
000048  d0e3              BEQ      |L3.18|
00004a  2103              MOVS     r1,#3                 ;684
00004c  a00b              ADR      r0,|L3.124|
00004e  f7fffffe          BL       UARTwrite
000052  1e64              SUBS     r4,r4,#1              ;684
000054  e7dd              B        |L3.18|
                  |L3.86|
000056  7828              LDRB     r0,[r5,#0]            ;702  ; bLastWasCR
000058  b120              CBZ      r0,|L3.100|
00005a  f8859000          STRB     r9,[r5,#0]            ;704
00005e  e7d8              B        |L3.18|
                  |L3.96|
000060  2001              MOVS     r0,#1                 ;720
000062  7028              STRB     r0,[r5,#0]            ;720
                  |L3.100|
;;;750            }
;;;751        }
;;;752    
;;;753        //
;;;754        // Add a null termination to the string.
;;;755        //
;;;756        pcBuf[ui32Count] = 0;
000064  f8089004          STRB     r9,[r8,r4]
;;;757    
;;;758        //
;;;759        // Send a CRLF pair to the terminal to end the line.
;;;760        //
;;;761        UARTwrite("\r\n", 2);
000068  2102              MOVS     r1,#2
00006a  a005              ADR      r0,|L3.128|
00006c  f7fffffe          BL       UARTwrite
;;;762    
;;;763        //
;;;764        // Return the count of int8_ts in the buffer, not counting the trailing 0.
;;;765        //
;;;766        return(ui32Count);
000070  4620              MOV      r0,r4
;;;767    #endif
;;;768    }
000072  e8bd87f0          POP      {r4-r10,pc}
;;;769    
                          ENDP

000076  0000              DCW      0x0000
                  |L3.120|
                          DCD      ||.data||
                  |L3.124|
00007c  08200800          DCB      "\b \b",0
                  |L3.128|
000080  0d0a00            DCB      "\r\n",0
000083  00                DCB      0

                          AREA ||i.UARTprintf||, CODE, READONLY, ALIGN=1

                  UARTprintf PROC
;;;1291   void
;;;1292   UARTprintf(const char *pcString, ...)
000000  b40f              PUSH     {r0-r3}
;;;1293   {
000002  b510              PUSH     {r4,lr}
;;;1294       va_list vaArgP;
;;;1295   
;;;1296       //
;;;1297       // Start the varargs processing.
;;;1298       //
;;;1299       va_start(vaArgP, pcString);
000004  a903              ADD      r1,sp,#0xc
;;;1300   
;;;1301       UARTvprintf(pcString, vaArgP);
000006  9802              LDR      r0,[sp,#8]
000008  f7fffffe          BL       UARTvprintf
;;;1302   
;;;1303       //
;;;1304       // We're finished with the varargs now.
;;;1305       //
;;;1306       va_end(vaArgP);
;;;1307   }
00000c  bc10              POP      {r4}
00000e  f85dfb14          LDR      pc,[sp],#0x14
;;;1308   
                          ENDP


                          AREA ||i.UARTvprintf||, CODE, READONLY, ALIGN=2

                  UARTvprintf PROC
;;;859    void
;;;860    UARTvprintf(const char *pcString, va_list vaArgP)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;861    {
000004  b085              SUB      sp,sp,#0x14
000006  460e              MOV      r6,r1
000008  4605              MOV      r5,r0
;;;862        uint32_t ui32Idx, ui32Value, ui32Pos, ui32Count, ui32Base, ui32Neg;
;;;863        char *pcStr, pcBuf[16], cFill;
;;;864    
;;;865        //
;;;866        // Check the arguments.
;;;867        //
;;;868        ASSERT(pcString != 0);
;;;869    
;;;870        //
;;;871        // Loop while there are more characters in the string.
;;;872        //
;;;873        while(*pcString)
;;;874        {
;;;875            //
;;;876            // Find the first non-% character, or the end of the string.
;;;877            //
;;;878            for(ui32Idx = 0;
;;;879                (pcString[ui32Idx] != '%') && (pcString[ui32Idx] != '\0');
;;;880                ui32Idx++)
;;;881            {
;;;882            }
;;;883    
;;;884            //
;;;885            // Write this portion of the string.
;;;886            //
;;;887            UARTwrite(pcString, ui32Idx);
;;;888    
;;;889            //
;;;890            // Skip the portion of the string that was written.
;;;891            //
;;;892            pcString += ui32Idx;
;;;893    
;;;894            //
;;;895            // See if the next character is a %.
;;;896            //
;;;897            if(*pcString == '%')
;;;898            {
;;;899                //
;;;900                // Skip the %.
;;;901                //
;;;902                pcString++;
;;;903    
;;;904                //
;;;905                // Set the digit count to zero, and the fill character to space
;;;906                // (in other words, to the defaults).
;;;907                //
;;;908                ui32Count = 0;
;;;909                cFill = ' ';
;;;910    
;;;911                //
;;;912                // It may be necessary to get back here to process more characters.
;;;913                // Goto's aren't pretty, but effective.  I feel extremely dirty for
;;;914                // using not one but two of the beasts.
;;;915                //
;;;916    again:
;;;917    
;;;918                //
;;;919                // Determine how to handle the next character.
;;;920                //
;;;921                switch(*pcString++)
;;;922                {
;;;923                    //
;;;924                    // Handle the digit characters.
;;;925                    //
;;;926                    case '0':
;;;927                    case '1':
;;;928                    case '2':
;;;929                    case '3':
;;;930                    case '4':
;;;931                    case '5':
;;;932                    case '6':
;;;933                    case '7':
;;;934                    case '8':
;;;935                    case '9':
;;;936                    {
;;;937                        //
;;;938                        // If this is a zero, and it is the first digit, then the
;;;939                        // fill character is a zero instead of a space.
;;;940                        //
;;;941                        if((pcString[-1] == '0') && (ui32Count == 0))
;;;942                        {
;;;943                            cFill = '0';
;;;944                        }
;;;945    
;;;946                        //
;;;947                        // Update the digit count.
;;;948                        //
;;;949                        ui32Count *= 10;
;;;950                        ui32Count += pcString[-1] - '0';
;;;951    
;;;952                        //
;;;953                        // Get the next character.
;;;954                        //
;;;955                        goto again;
;;;956                    }
;;;957    
;;;958                    //
;;;959                    // Handle the %c command.
;;;960                    //
;;;961                    case 'c':
;;;962                    {
;;;963                        //
;;;964                        // Get the value from the varargs.
;;;965                        //
;;;966                        ui32Value = va_arg(vaArgP, uint32_t);
;;;967    
;;;968                        //
;;;969                        // Print out the character.
;;;970                        //
;;;971                        UARTwrite((char *)&ui32Value, 1);
;;;972    
;;;973                        //
;;;974                        // This command has been handled.
;;;975                        //
;;;976                        break;
;;;977                    }
;;;978    
;;;979                    //
;;;980                    // Handle the %d and %i commands.
;;;981                    //
;;;982                    case 'd':
;;;983                    case 'i':
;;;984                    {
;;;985                        //
;;;986                        // Get the value from the varargs.
;;;987                        //
;;;988                        ui32Value = va_arg(vaArgP, uint32_t);
;;;989    
;;;990                        //
;;;991                        // Reset the buffer position.
;;;992                        //
;;;993                        ui32Pos = 0;
;;;994    
;;;995                        //
;;;996                        // If the value is negative, make it positive and indicate
;;;997                        // that a minus sign is needed.
;;;998                        //
;;;999                        if((int32_t)ui32Value < 0)
;;;1000                       {
;;;1001                           //
;;;1002                           // Make the value positive.
;;;1003                           //
;;;1004                           ui32Value = -(int32_t)ui32Value;
;;;1005   
;;;1006                           //
;;;1007                           // Indicate that the value is negative.
;;;1008                           //
;;;1009                           ui32Neg = 1;
;;;1010                       }
;;;1011                       else
;;;1012                       {
;;;1013                           //
;;;1014                           // Indicate that the value is positive so that a minus
;;;1015                           // sign isn't inserted.
;;;1016                           //
;;;1017                           ui32Neg = 0;
;;;1018                       }
;;;1019   
;;;1020                       //
;;;1021                       // Set the base to 10.
;;;1022                       //
;;;1023                       ui32Base = 10;
;;;1024   
;;;1025                       //
;;;1026                       // Convert the value to ASCII.
;;;1027                       //
;;;1028                       goto convert;
;;;1029                   }
;;;1030   
;;;1031                   //
;;;1032                   // Handle the %s command.
;;;1033                   //
;;;1034                   case 's':
;;;1035                   {
;;;1036                       //
;;;1037                       // Get the string pointer from the varargs.
;;;1038                       //
;;;1039                       pcStr = va_arg(vaArgP, char *);
;;;1040   
;;;1041                       //
;;;1042                       // Determine the length of the string.
;;;1043                       //
;;;1044                       for(ui32Idx = 0; pcStr[ui32Idx] != '\0'; ui32Idx++)
;;;1045                       {
;;;1046                       }
;;;1047   
;;;1048                       //
;;;1049                       // Write the string.
;;;1050                       //
;;;1051                       UARTwrite(pcStr, ui32Idx);
;;;1052   
;;;1053                       //
;;;1054                       // Write any required padding spaces
;;;1055                       //
;;;1056                       if(ui32Count > ui32Idx)
;;;1057                       {
;;;1058                           ui32Count -= ui32Idx;
;;;1059                           while(ui32Count--)
;;;1060                           {
;;;1061                               UARTwrite(" ", 1);
;;;1062                           }
;;;1063                       }
;;;1064   
;;;1065                       //
;;;1066                       // This command has been handled.
;;;1067                       //
;;;1068                       break;
;;;1069                   }
;;;1070   
;;;1071                   //
;;;1072                   // Handle the %u command.
;;;1073                   //
;;;1074                   case 'u':
;;;1075                   {
;;;1076                       //
;;;1077                       // Get the value from the varargs.
;;;1078                       //
;;;1079                       ui32Value = va_arg(vaArgP, uint32_t);
;;;1080   
;;;1081                       //
;;;1082                       // Reset the buffer position.
;;;1083                       //
;;;1084                       ui32Pos = 0;
;;;1085   
;;;1086                       //
;;;1087                       // Set the base to 10.
;;;1088                       //
;;;1089                       ui32Base = 10;
;;;1090   
;;;1091                       //
;;;1092                       // Indicate that the value is positive so that a minus sign
;;;1093                       // isn't inserted.
;;;1094                       //
;;;1095                       ui32Neg = 0;
;;;1096   
;;;1097                       //
;;;1098                       // Convert the value to ASCII.
;;;1099                       //
;;;1100                       goto convert;
;;;1101                   }
;;;1102   
;;;1103                   //
;;;1104                   // Handle the %x and %X commands.  Note that they are treated
;;;1105                   // identically; in other words, %X will use lower case letters
;;;1106                   // for a-f instead of the upper case letters it should use.  We
;;;1107                   // also alias %p to %x.
;;;1108                   //
;;;1109                   case 'x':
;;;1110                   case 'X':
;;;1111                   case 'p':
;;;1112                   {
;;;1113                       //
;;;1114                       // Get the value from the varargs.
;;;1115                       //
;;;1116                       ui32Value = va_arg(vaArgP, uint32_t);
;;;1117   
;;;1118                       //
;;;1119                       // Reset the buffer position.
;;;1120                       //
;;;1121                       ui32Pos = 0;
;;;1122   
;;;1123                       //
;;;1124                       // Set the base to 16.
;;;1125                       //
;;;1126                       ui32Base = 16;
;;;1127   
;;;1128                       //
;;;1129                       // Indicate that the value is positive so that a minus sign
;;;1130                       // isn't inserted.
;;;1131                       //
;;;1132                       ui32Neg = 0;
;;;1133   
;;;1134                       //
;;;1135                       // Determine the number of digits in the string version of
;;;1136                       // the value.
;;;1137                       //
;;;1138   convert:
;;;1139                       for(ui32Idx = 1;
;;;1140                           (((ui32Idx * ui32Base) <= ui32Value) &&
;;;1141                            (((ui32Idx * ui32Base) / ui32Base) == ui32Idx));
;;;1142                           ui32Idx *= ui32Base, ui32Count--)
;;;1143                       {
;;;1144                       }
;;;1145   
;;;1146                       //
;;;1147                       // If the value is negative, reduce the count of padding
;;;1148                       // characters needed.
;;;1149                       //
;;;1150                       if(ui32Neg)
;;;1151                       {
;;;1152                           ui32Count--;
;;;1153                       }
;;;1154   
;;;1155                       //
;;;1156                       // If the value is negative and the value is padded with
;;;1157                       // zeros, then place the minus sign before the padding.
;;;1158                       //
;;;1159                       if(ui32Neg && (cFill == '0'))
;;;1160                       {
;;;1161                           //
;;;1162                           // Place the minus sign in the output buffer.
;;;1163                           //
;;;1164                           pcBuf[ui32Pos++] = '-';
00000a  f04f0b2d          MOV      r11,#0x2d
00000e  f10d0a04          ADD      r10,sp,#4             ;863
000012  e0c0              B        |L5.406|
                  |L5.20|
000014  2400              MOVS     r4,#0                 ;878
000016  e000              B        |L5.26|
                  |L5.24|
000018  1c64              ADDS     r4,r4,#1              ;878
                  |L5.26|
00001a  5d28              LDRB     r0,[r5,r4]            ;879
00001c  2825              CMP      r0,#0x25              ;879
00001e  d001              BEQ      |L5.36|
000020  2800              CMP      r0,#0                 ;879
000022  d1f9              BNE      |L5.24|
                  |L5.36|
000024  4621              MOV      r1,r4                 ;887
000026  4628              MOV      r0,r5                 ;887
000028  f7fffffe          BL       UARTwrite
00002c  4425              ADD      r5,r5,r4              ;892
00002e  7828              LDRB     r0,[r5,#0]            ;897
000030  2825              CMP      r0,#0x25              ;897
000032  d173              BNE      |L5.284|
000034  2400              MOVS     r4,#0                 ;908
000036  2720              MOVS     r7,#0x20              ;909
000038  1c6d              ADDS     r5,r5,#1              ;909
                  |L5.58|
00003a  f8150b01          LDRB     r0,[r5],#1            ;921
00003e  2838              CMP      r0,#0x38              ;921
000040  d02c              BEQ      |L5.156|
000042  dc14              BGT      |L5.110|
000044  2833              CMP      r0,#0x33              ;921
000046  d029              BEQ      |L5.156|
000048  dc08              BGT      |L5.92|
00004a  2825              CMP      r0,#0x25              ;921
00004c  d067              BEQ      |L5.286|
00004e  2830              CMP      r0,#0x30              ;921
000050  d024              BEQ      |L5.156|
000052  2831              CMP      r0,#0x31              ;921
000054  d022              BEQ      |L5.156|
000056  2832              CMP      r0,#0x32              ;921
000058  d11d              BNE      |L5.150|
00005a  e01f              B        |L5.156|
                  |L5.92|
00005c  2834              CMP      r0,#0x34              ;921
00005e  d01d              BEQ      |L5.156|
000060  2835              CMP      r0,#0x35              ;921
000062  d01b              BEQ      |L5.156|
000064  2836              CMP      r0,#0x36              ;921
000066  d019              BEQ      |L5.156|
000068  2837              CMP      r0,#0x37              ;921
00006a  d114              BNE      |L5.150|
00006c  e016              B        |L5.156|
                  |L5.110|
00006e  2869              CMP      r0,#0x69              ;921
000070  d025              BEQ      |L5.190|
000072  dc08              BGT      |L5.134|
000074  2839              CMP      r0,#0x39              ;921
000076  d011              BEQ      |L5.156|
000078  2858              CMP      r0,#0x58              ;921
00007a  d046              BEQ      |L5.266|
00007c  2863              CMP      r0,#0x63              ;921
00007e  d019              BEQ      |L5.180|
000080  2864              CMP      r0,#0x64              ;921
000082  d108              BNE      |L5.150|
000084  e01b              B        |L5.190|
                  |L5.134|
000086  2870              CMP      r0,#0x70              ;921
000088  d03f              BEQ      |L5.266|
00008a  2873              CMP      r0,#0x73              ;921
00008c  d023              BEQ      |L5.214|
00008e  2875              CMP      r0,#0x75              ;921
000090  d036              BEQ      |L5.256|
000092  2878              CMP      r0,#0x78              ;921
000094  d039              BEQ      |L5.266|
                  |L5.150|
;;;1165   
;;;1166                           //
;;;1167                           // The minus sign has been placed, so turn off the
;;;1168                           // negative flag.
;;;1169                           //
;;;1170                           ui32Neg = 0;
;;;1171                       }
;;;1172   
;;;1173                       //
;;;1174                       // Provide additional padding at the beginning of the
;;;1175                       // string conversion if needed.
;;;1176                       //
;;;1177                       if((ui32Count > 1) && (ui32Count < 16))
;;;1178                       {
;;;1179                           for(ui32Count--; ui32Count; ui32Count--)
;;;1180                           {
;;;1181                               pcBuf[ui32Pos++] = cFill;
;;;1182                           }
;;;1183                       }
;;;1184   
;;;1185                       //
;;;1186                       // If the value is negative, then place the minus sign
;;;1187                       // before the number.
;;;1188                       //
;;;1189                       if(ui32Neg)
;;;1190                       {
;;;1191                           //
;;;1192                           // Place the minus sign in the output buffer.
;;;1193                           //
;;;1194                           pcBuf[ui32Pos++] = '-';
;;;1195                       }
;;;1196   
;;;1197                       //
;;;1198                       // Convert the value into a string.
;;;1199                       //
;;;1200                       for(; ui32Idx; ui32Idx /= ui32Base)
;;;1201                       {
;;;1202                           pcBuf[ui32Pos++] =
;;;1203                               g_pcHex[(ui32Value / ui32Idx) % ui32Base];
;;;1204                       }
;;;1205   
;;;1206                       //
;;;1207                       // Write the string.
;;;1208                       //
;;;1209                       UARTwrite(pcBuf, ui32Pos);
;;;1210   
;;;1211                       //
;;;1212                       // This command has been handled.
;;;1213                       //
;;;1214                       break;
;;;1215                   }
;;;1216   
;;;1217                   //
;;;1218                   // Handle the %% command.
;;;1219                   //
;;;1220                   case '%':
;;;1221                   {
;;;1222                       //
;;;1223                       // Simply write a single %.
;;;1224                       //
;;;1225                       UARTwrite(pcString - 1, 1);
;;;1226   
;;;1227                       //
;;;1228                       // This command has been handled.
;;;1229                       //
;;;1230                       break;
;;;1231                   }
;;;1232   
;;;1233                   //
;;;1234                   // Handle all other commands.
;;;1235                   //
;;;1236                   default:
;;;1237                   {
;;;1238                       //
;;;1239                       // Indicate an error.
;;;1240                       //
;;;1241                       UARTwrite("ERROR", 5);
000096  2105              MOVS     r1,#5
000098  a042              ADR      r0,|L5.420|
;;;1242   
;;;1243                       //
;;;1244                       // This command has been handled.
;;;1245                       //
;;;1246                       break;
00009a  e07a              B        |L5.402|
                  |L5.156|
00009c  f8150c01          LDRB     r0,[r5,#-1]           ;941
0000a0  2830              CMP      r0,#0x30              ;941
0000a2  d101              BNE      |L5.168|
0000a4  b904              CBNZ     r4,|L5.168|
0000a6  2730              MOVS     r7,#0x30              ;943
                  |L5.168|
0000a8  eb040184          ADD      r1,r4,r4,LSL #2       ;949
0000ac  0049              LSLS     r1,r1,#1              ;949
0000ae  3930              SUBS     r1,r1,#0x30           ;949
0000b0  1844              ADDS     r4,r0,r1              ;950
0000b2  e7c2              B        |L5.58|
                  |L5.180|
0000b4  ce01              LDM      r6!,{r0}              ;966
0000b6  9000              STR      r0,[sp,#0]            ;971
0000b8  2101              MOVS     r1,#1                 ;971
0000ba  4668              MOV      r0,sp                 ;971
0000bc  e069              B        |L5.402|
                  |L5.190|
0000be  ce01              LDM      r6!,{r0}              ;988
0000c0  2100              MOVS     r1,#0                 ;993
0000c2  9000              STR      r0,[sp,#0]            ;999
0000c4  2800              CMP      r0,#0                 ;999
0000c6  da03              BGE      |L5.208|
0000c8  4240              RSBS     r0,r0,#0              ;1004
0000ca  2301              MOVS     r3,#1                 ;1009
0000cc  9000              STR      r0,[sp,#0]            ;1009
0000ce  e000              B        |L5.210|
                  |L5.208|
0000d0  2300              MOVS     r3,#0                 ;1017
                  |L5.210|
0000d2  220a              MOVS     r2,#0xa               ;1023
0000d4  e01e              B        |L5.276|
                  |L5.214|
0000d6  ce01              LDM      r6!,{r0}              ;1039
0000d8  2700              MOVS     r7,#0                 ;1044
0000da  e000              B        |L5.222|
                  |L5.220|
0000dc  1c7f              ADDS     r7,r7,#1              ;1044
                  |L5.222|
0000de  5dc1              LDRB     r1,[r0,r7]            ;1044
0000e0  2900              CMP      r1,#0                 ;1044
0000e2  d1fb              BNE      |L5.220|
0000e4  4639              MOV      r1,r7                 ;1051
0000e6  f7fffffe          BL       UARTwrite
0000ea  42bc              CMP      r4,r7                 ;1056
0000ec  d953              BLS      |L5.406|
0000ee  1be4              SUBS     r4,r4,r7              ;1058
0000f0  e003              B        |L5.250|
                  |L5.242|
0000f2  2101              MOVS     r1,#1                 ;1061
0000f4  a02d              ADR      r0,|L5.428|
0000f6  f7fffffe          BL       UARTwrite
                  |L5.250|
0000fa  1e64              SUBS     r4,r4,#1              ;1061
0000fc  d34b              BCC      |L5.406|
0000fe  e7f8              B        |L5.242|
                  |L5.256|
000100  ce01              LDM      r6!,{r0}              ;1079
000102  2100              MOVS     r1,#0                 ;1084
000104  220a              MOVS     r2,#0xa               ;1089
000106  9000              STR      r0,[sp,#0]            ;1100
000108  e003              B        |L5.274|
                  |L5.266|
00010a  ce01              LDM      r6!,{r0}              ;1116
00010c  2100              MOVS     r1,#0                 ;1121
00010e  2210              MOVS     r2,#0x10              ;1126
000110  9000              STR      r0,[sp,#0]            ;1126
                  |L5.274|
000112  2300              MOVS     r3,#0                 ;1132
                  |L5.276|
000114  2001              MOVS     r0,#1                 ;1139
000116  f8dd9000          LDR      r9,[sp,#0]            ;1139
00011a  e003              B        |L5.292|
                  |L5.284|
00011c  e03b              B        |L5.406|
                  |L5.286|
00011e  e036              B        |L5.398|
                  |L5.288|
000120  4660              MOV      r0,r12                ;1139
000122  1e64              SUBS     r4,r4,#1              ;1139
                  |L5.292|
000124  fb00fc02          MUL      r12,r0,r2             ;1140
000128  45cc              CMP      r12,r9                ;1140
00012a  d803              BHI      |L5.308|
00012c  fbbcf8f2          UDIV     r8,r12,r2             ;1141
000130  4580              CMP      r8,r0                 ;1141
000132  d0f5              BEQ      |L5.288|
                  |L5.308|
000134  b133              CBZ      r3,|L5.324|
000136  1e64              SUBS     r4,r4,#1              ;1150
000138  2f30              CMP      r7,#0x30              ;1159
00013a  d103              BNE      |L5.324|
00013c  f80ab001          STRB     r11,[r10,r1]          ;1164
000140  2300              MOVS     r3,#0                 ;1170
000142  1c49              ADDS     r1,r1,#1              ;1170
                  |L5.324|
000144  f1a40c02          SUB      r12,r4,#2             ;1177
000148  f1bc0f0e          CMP      r12,#0xe              ;1177
00014c  d207              BCS      |L5.350|
00014e  1e64              SUBS     r4,r4,#1              ;1177
000150  d005              BEQ      |L5.350|
000152  46d4              MOV      r12,r10               ;863
                  |L5.340|
000154  f80c7001          STRB     r7,[r12,r1]           ;1181
000158  1c49              ADDS     r1,r1,#1              ;1181
00015a  1e64              SUBS     r4,r4,#1              ;1181
00015c  d1fa              BNE      |L5.340|
                  |L5.350|
00015e  b113              CBZ      r3,|L5.358|
000160  f80ab001          STRB     r11,[r10,r1]          ;1194
000164  1c49              ADDS     r1,r1,#1              ;1194
                  |L5.358|
000166  4f12              LDR      r7,|L5.432|
000168  4654              MOV      r4,r10                ;863
                  |L5.362|
00016a  b170              CBZ      r0,|L5.394|
00016c  fbb9f3f0          UDIV     r3,r9,r0              ;1202
000170  fbb3fcf2          UDIV     r12,r3,r2             ;1202
000174  fb02331c          MLS      r3,r2,r12,r3          ;1202
000178  f8d7c000          LDR      r12,[r7,#0]           ;1202  ; g_pcHex
00017c  fbb0f0f2          UDIV     r0,r0,r2              ;1200
000180  f81c3003          LDRB     r3,[r12,r3]           ;1202
000184  5463              STRB     r3,[r4,r1]            ;1202
000186  1c49              ADDS     r1,r1,#1              ;1200
000188  e7ef              B        |L5.362|
                  |L5.394|
00018a  a801              ADD      r0,sp,#4              ;1209
00018c  e001              B        |L5.402|
                  |L5.398|
00018e  2101              MOVS     r1,#1                 ;1225
000190  1e68              SUBS     r0,r5,#1              ;1225
                  |L5.402|
000192  f7fffffe          BL       UARTwrite
                  |L5.406|
000196  7828              LDRB     r0,[r5,#0]            ;873
000198  2800              CMP      r0,#0                 ;873
00019a  f47faf3b          BNE      |L5.20|
;;;1247                   }
;;;1248               }
;;;1249           }
;;;1250       }
;;;1251   }
00019e  b005              ADD      sp,sp,#0x14
0001a0  e8bd8ff0          POP      {r4-r11,pc}
;;;1252   
                          ENDP

                  |L5.420|
0001a4  4552524f          DCB      "ERROR",0
0001a8  5200    
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L5.428|
0001ac  2000              DCB      " ",0
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L5.432|
                          DCD      ||.constdata||

                          AREA ||i.UARTwrite||, CODE, READONLY, ALIGN=2

                  UARTwrite PROC
;;;435    int
;;;436    UARTwrite(const char *pcBuf, uint32_t ui32Len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;437    {
000004  4688              MOV      r8,r1
000006  4605              MOV      r5,r0
;;;438    #ifdef UART_BUFFERED
;;;439        unsigned int uIdx;
;;;440    
;;;441        //
;;;442        // Check for valid arguments.
;;;443        //
;;;444        ASSERT(pcBuf != 0);
;;;445        ASSERT(g_ui32Base != 0);
;;;446    
;;;447        //
;;;448        // Send the characters
;;;449        //
;;;450        for(uIdx = 0; uIdx < ui32Len; uIdx++)
;;;451        {
;;;452            //
;;;453            // If the character to the UART is \n, then add a \r before it so that
;;;454            // \n is translated to \n\r in the output.
;;;455            //
;;;456            if(pcBuf[uIdx] == '\n')
;;;457            {
;;;458                if(!TX_BUFFER_FULL)
;;;459                {
;;;460                    g_pcUARTTxBuffer[g_ui32UARTTxWriteIndex] = '\r';
;;;461                    ADVANCE_TX_BUFFER_INDEX(g_ui32UARTTxWriteIndex);
;;;462                }
;;;463                else
;;;464                {
;;;465                    //
;;;466                    // Buffer is full - discard remaining characters and return.
;;;467                    //
;;;468                    break;
;;;469                }
;;;470            }
;;;471    
;;;472            //
;;;473            // Send the character to the UART output.
;;;474            //
;;;475            if(!TX_BUFFER_FULL)
;;;476            {
;;;477                g_pcUARTTxBuffer[g_ui32UARTTxWriteIndex] = pcBuf[uIdx];
;;;478                ADVANCE_TX_BUFFER_INDEX(g_ui32UARTTxWriteIndex);
;;;479            }
;;;480            else
;;;481            {
;;;482                //
;;;483                // Buffer is full - discard remaining characters and return.
;;;484                //
;;;485                break;
;;;486            }
;;;487        }
;;;488    
;;;489        //
;;;490        // If we have anything in the buffer, make sure that the UART is set
;;;491        // up to transmit it.
;;;492        //
;;;493        if(!TX_BUFFER_EMPTY)
;;;494        {
;;;495            UARTPrimeTransmit(g_ui32Base);
;;;496            MAP_UARTIntEnable(g_ui32Base, UART_INT_TX);
;;;497        }
;;;498    
;;;499        //
;;;500        // Return the number of characters written.
;;;501        //
;;;502        return(uIdx);
;;;503    #else
;;;504        unsigned int uIdx;
;;;505    
;;;506        //
;;;507        // Check for valid UART base address, and valid arguments.
;;;508        //
;;;509        ASSERT(g_ui32Base != 0);
;;;510        ASSERT(pcBuf != 0);
;;;511    
;;;512        //
;;;513        // Send the characters
;;;514        //
;;;515        for(uIdx = 0; uIdx < ui32Len; uIdx++)
000008  2400              MOVS     r4,#0
;;;516        {
;;;517            //
;;;518            // If the character to the UART is \n, then add a \r before it so that
;;;519            // \n is translated to \n\r in the output.
;;;520            //
;;;521            if(pcBuf[uIdx] == '\n')
;;;522            {
;;;523                MAP_UARTCharPut(g_ui32Base, '\r');
00000a  f04f7680          MOV      r6,#0x1000000
00000e  4f0a              LDR      r7,|L6.56|
000010  e00d              B        |L6.46|
                  |L6.18|
000012  5d28              LDRB     r0,[r5,r4]            ;521
000014  280a              CMP      r0,#0xa               ;521
000016  d104              BNE      |L6.34|
000018  6970              LDR      r0,[r6,#0x14]
00001a  210d              MOVS     r1,#0xd
00001c  6802              LDR      r2,[r0,#0]
00001e  6878              LDR      r0,[r7,#4]  ; g_ui32Base
000020  4790              BLX      r2
                  |L6.34|
;;;524            }
;;;525    
;;;526            //
;;;527            // Send the character to the UART output.
;;;528            //
;;;529            MAP_UARTCharPut(g_ui32Base, pcBuf[uIdx]);
000022  6970              LDR      r0,[r6,#0x14]
000024  5d29              LDRB     r1,[r5,r4]
000026  6802              LDR      r2,[r0,#0]
000028  6878              LDR      r0,[r7,#4]  ; g_ui32Base
00002a  4790              BLX      r2
00002c  1c64              ADDS     r4,r4,#1
                  |L6.46|
00002e  4544              CMP      r4,r8                 ;515
000030  d3ef              BCC      |L6.18|
;;;530        }
;;;531    
;;;532        //
;;;533        // Return the number of characters written.
;;;534        //
;;;535        return(uIdx);
000032  4620              MOV      r0,r4
;;;536    #endif
;;;537    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;538    
                          ENDP

                  |L6.56|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_pcHex
                          DCD      ||.conststring||
                  g_ui32UARTBase
                          DCD      0x4000c000
                          DCD      0x4000d000
                          DCD      0x4000e000
                  g_ui32UARTPeriph
                          DCD      0xf0001800
                          DCD      0xf0001801
                          DCD      0xf0001802

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  30313233          DCB      "0123456789abcdef",0
000004  34353637
000008  38396162
00000c  63646566
000010  00      

                          AREA ||.data||, DATA, ALIGN=2

                  bLastWasCR
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_ui32Base
                          DCD      0x00000000
