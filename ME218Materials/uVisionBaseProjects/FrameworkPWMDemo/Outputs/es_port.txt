; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\outputs\es_port.o --asm_dir=.\Outputs\ --list_dir=.\Outputs\ --depend=.\outputs\es_port.d --cpu=Cortex-M4.fp --apcs=interwork -IC:\ti\TivaWare_C_Series-2.1.0.12573 -I.\Headers -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.0.0\Device\Include\TM4C123 -DTM4C123GH6PM -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RB1 --omf_browse=.\outputs\es_port.crf Source\ES_Port.c]
                          THUMB

                          AREA ||i.CPUgetPRIMASK_cpsid||, CODE, READONLY, ALIGN=1

                  CPUgetPRIMASK_cpsid PROC
;;;198    #if defined(rvmdk) || defined(__ARMCC_VERSION)
;;;199    uint32_t CPUgetPRIMASK_cpsid(void)
000000  f3ef8010          MRS      r0,PRIMASK
;;;200    {
;;;201      register uint32_t r0;
;;;202      __asm
;;;203      {
;;;204        mrs     r0, PRIMASK;	  // Store PRIMASK in r0
;;;205        cpsid   i;				      // Disable interrupts
000004  b672              CPSID    i
;;;206      }
;;;207      return r0;
;;;208    }
000006  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||i.CPUsetPRIMASK||, CODE, READONLY, ALIGN=1

                  CPUsetPRIMASK PROC
;;;209    
;;;210    void CPUsetPRIMASK(uint32_t newPRIMASK)
000000  f3808810          MSR      PRIMASK,r0
;;;211    {
;;;212      __asm
;;;213      {
;;;214        msr     PRIMASK, newPRIMASK		  // Store newPRIMASK in PRIMASK
;;;215      }
;;;216    }
000004  4770              BX       lr
;;;217    
                          ENDP


                          AREA ||i.ConsoleInit||, CODE, READONLY, ALIGN=2

                  ConsoleInit PROC
;;;175     ****************************************************************************/
;;;176    void ConsoleInit(void)
000000  b510              PUSH     {r4,lr}
;;;177    {
;;;178    	// Enable designated port that will be used for the UART
;;;179    	SysCtlPeripheralEnable( SYSCTL_PERIPH_GPIOA );
000002  480f              LDR      r0,|L3.64|
000004  f7fffffe          BL       SysCtlPeripheralEnable
;;;180    
;;;181    	// Enable the designated UART
;;;182    	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
000008  480e              LDR      r0,|L3.68|
00000a  f7fffffe          BL       SysCtlPeripheralEnable
;;;183    
;;;184    	// Configure pins for UART including setup for alternate (UART) functionality
;;;185    	GPIOPinConfigure(GPIO_PA0_U0RX);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       GPIOPinConfigure
;;;186    	GPIOPinConfigure(GPIO_PA1_U0TX);
000014  f2404001          MOV      r0,#0x401
000018  f7fffffe          BL       GPIOPinConfigure
;;;187    	GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
00001c  2103              MOVS     r1,#3
00001e  f04f2040          MOV      r0,#0x40004000
000022  f7fffffe          BL       GPIOPinTypeUART
;;;188    
;;;189    	// Select the clock source
;;;190    	UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
000026  2105              MOVS     r1,#5
000028  4807              LDR      r0,|L3.72|
00002a  f7fffffe          BL       UARTClockSourceSet
;;;191    
;;;192    	// Initialize the UART for console I/O
;;;193    	UARTStdioConfig(UART_PORT, UART_BAUD, SRC_CLK_FREQ);
00002e  e8bd4010          POP      {r4,lr}
000032  4a06              LDR      r2,|L3.76|
000034  f44f31e1          MOV      r1,#0x1c200
000038  2000              MOVS     r0,#0
00003a  f7ffbffe          B.W      UARTStdioConfig
;;;194    
;;;195    }
;;;196    
                          ENDP

00003e  0000              DCW      0x0000
                  |L3.64|
                          DCD      0xf0000800
                  |L3.68|
                          DCD      0xf0001800
                  |L3.72|
                          DCD      0x4000c000
                  |L3.76|
                          DCD      0x00f42400

                          AREA ||i.SysTickIntHandler||, CODE, READONLY, ALIGN=2

                  SysTickIntHandler PROC
;;;99     ****************************************************************************/
;;;100    void SysTickIntHandler(void)
000000  4803              LDR      r0,|L4.16|
;;;101    {
;;;102    	/* Interrupt automatically cleared by hardware */
;;;103      ++TickCount;          /* flag that it occurred and needs a response */
000002  7801              LDRB     r1,[r0,#0]  ; TickCount
000004  1c49              ADDS     r1,r1,#1
000006  7001              STRB     r1,[r0,#0]
;;;104    	++SysTickCounter;     // keep the free running time going
000008  8841              LDRH     r1,[r0,#2]  ; SysTickCounter
00000a  1c49              ADDS     r1,r1,#1
00000c  8041              STRH     r1,[r0,#2]
;;;105    #ifdef LED_DEBUG
;;;106    	BlinkLED();
;;;107    #endif
;;;108    }
00000e  4770              BX       lr
;;;109    
                          ENDP

                  |L4.16|
                          DCD      ||.data||

                          AREA ||i._HW_GetTickCount||, CODE, READONLY, ALIGN=2

                  _HW_GetTickCount PROC
;;;124    ****************************************************************************/
;;;125    uint16_t _HW_GetTickCount(void)
000000  4801              LDR      r0,|L5.8|
;;;126    {
;;;127       return (SysTickCounter);
000002  8840              LDRH     r0,[r0,#2]  ; SysTickCounter
;;;128    }
000004  4770              BX       lr
;;;129    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i._HW_Process_Pending_Ints||, CODE, READONLY, ALIGN=2

                  _HW_Process_Pending_Ints PROC
;;;150    ****************************************************************************/
;;;151    bool _HW_Process_Pending_Ints( void )
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153       while (TickCount > 0)
;;;154       {
;;;155          /* call the framework tick response to actually run the timers */
;;;156          ES_Timer_Tick_Resp();  
;;;157          TickCount--;
000002  4c06              LDR      r4,|L6.28|
000004  e004              B        |L6.16|
                  |L6.6|
000006  f7fffffe          BL       ES_Timer_Tick_Resp
00000a  7820              LDRB     r0,[r4,#0]  ; TickCount
00000c  1e40              SUBS     r0,r0,#1
00000e  7020              STRB     r0,[r4,#0]
                  |L6.16|
000010  7820              LDRB     r0,[r4,#0]            ;153  ; TickCount
000012  2800              CMP      r0,#0                 ;153
000014  d1f7              BNE      |L6.6|
;;;158       }
;;;159       return true; // always return true to allow loop test in ES_Run to proceed
000016  2001              MOVS     r0,#1
;;;160    }
000018  bd10              POP      {r4,pc}
;;;161    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      ||.data||

                          AREA ||i._HW_Timer_Init||, CODE, READONLY, ALIGN=1

                  _HW_Timer_Init PROC
;;;73     ****************************************************************************/
;;;74     void _HW_Timer_Init(TimerRate_t Rate)
000000  b510              PUSH     {r4,lr}
;;;75     {
;;;76     	SysTickPeriodSet(Rate);			/* Set the SysTick Interrupt Rate */
000002  f7fffffe          BL       SysTickPeriodSet
;;;77     	SysTickIntEnable();				/* Enable the SysTick Interrupt */
000006  f7fffffe          BL       SysTickIntEnable
;;;78     	SysTickEnable();				/* Enable SysTick */
00000a  f7fffffe          BL       SysTickEnable
;;;79     	IntMasterEnable();				/* Make sure interrupts are enabled */
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      IntMasterEnable
;;;80     
;;;81     }
;;;82     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  TickCount
000000  0000              DCB      0x00,0x00
                  SysTickCounter
000002  0000              DCW      0x0000
