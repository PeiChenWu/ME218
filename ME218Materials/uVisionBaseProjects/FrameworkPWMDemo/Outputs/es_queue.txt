; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\outputs\es_queue.o --asm_dir=.\Outputs\ --list_dir=.\Outputs\ --depend=.\outputs\es_queue.d --cpu=Cortex-M4.fp --apcs=interwork -IC:\ti\TivaWare_C_Series-2.1.0.12573 -I.\Headers -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\TM4C_DFP\1.0.0\Device\Include\TM4C123 -DTM4C123GH6PM -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RB1 --omf_browse=.\outputs\es_queue.crf Source\ES_Queue.c]
                          THUMB

                          AREA ||i.ES_DeQueue||, CODE, READONLY, ALIGN=2

                  ES_DeQueue PROC
;;;161    ****************************************************************************/
;;;162    uint8_t ES_DeQueue( ES_Event * pBlock, ES_Event * pReturnEvent )
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  4604              MOV      r4,r0
;;;164       pQueue_t pThisQueue;
;;;165       uint8_t NumLeft;
;;;166    
;;;167       pThisQueue = (pQueue_t)pBlock;
;;;168       if ( pThisQueue->NumEntries > 0)
000004  7880              LDRB     r0,[r0,#2]
000006  460d              MOV      r5,r1                 ;163
000008  b1e0              CBZ      r0,|L1.68|
;;;169       {
;;;170          EnterCritical();   // save interrupt state, turn ints off
00000a  f7fffffe          BL       CPUgetPRIMASK_cpsid
00000e  4a10              LDR      r2,|L1.80|
;;;171          *pReturnEvent = pBlock[ 1 + pThisQueue->CurrentIndex ];
000010  6010              STR      r0,[r2,#0]  ; _PRIMASK_temp
000012  7861              LDRB     r1,[r4,#1]
000014  eb040081          ADD      r0,r4,r1,LSL #2
000018  6840              LDR      r0,[r0,#4]
00001a  6028              STR      r0,[r5,#0]
;;;172          // inc the index
;;;173          pThisQueue->CurrentIndex++;
00001c  7860              LDRB     r0,[r4,#1]
00001e  1c40              ADDS     r0,r0,#1
000020  b2c0              UXTB     r0,r0
000022  7060              STRB     r0,[r4,#1]
;;;174          // this way we only do the modulo operation when we really need to
;;;175          if (pThisQueue->CurrentIndex >=  pThisQueue->QueueSize)
000024  7821              LDRB     r1,[r4,#0]
000026  4288              CMP      r0,r1
000028  d304              BCC      |L1.52|
;;;176             pThisQueue->CurrentIndex = (uint8_t)(pThisQueue->CurrentIndex % pThisQueue->QueueSize);
00002a  fbb0f3f1          UDIV     r3,r0,r1
00002e  fb010013          MLS      r0,r1,r3,r0
000032  7060              STRB     r0,[r4,#1]
                  |L1.52|
;;;177          //dec number of elements since we took 1 out
;;;178          NumLeft = --pThisQueue->NumEntries; 
000034  78a0              LDRB     r0,[r4,#2]
000036  1e40              SUBS     r0,r0,#1
000038  b2c5              UXTB     r5,r0
00003a  70a5              STRB     r5,[r4,#2]
;;;179          ExitCritical();  // restore saved interrupt state
00003c  6810              LDR      r0,[r2,#0]  ; _PRIMASK_temp
00003e  f7fffffe          BL       CPUsetPRIMASK
000042  e003              B        |L1.76|
                  |L1.68|
;;;180       }else { // no items left in the queue
;;;181          (*pReturnEvent).EventType = ES_NO_EVENT;
000044  2000              MOVS     r0,#0
000046  7028              STRB     r0,[r5,#0]
;;;182          (*pReturnEvent).EventParam = 0;
000048  8048              STRH     r0,[r1,#2]
;;;183          NumLeft = 0;
00004a  4605              MOV      r5,r0
                  |L1.76|
;;;184       }
;;;185       return NumLeft;
00004c  4628              MOV      r0,r5
;;;186    }
00004e  bd70              POP      {r4-r6,pc}
;;;187    
                          ENDP

                  |L1.80|
                          DCD      ||.data||

                          AREA ||i.ES_EnQueueFIFO||, CODE, READONLY, ALIGN=2

                  ES_EnQueueFIFO PROC
;;;84     ****************************************************************************/
;;;85     bool ES_EnQueueFIFO( ES_Event * pBlock, ES_Event Event2Add )
000000  b570              PUSH     {r4-r6,lr}
;;;86     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;87        pQueue_t pThisQueue;
;;;88        pThisQueue = (pQueue_t)pBlock;
;;;89        // index will go from 0 to QueueSize-1 so use '<' to test if there is space
;;;90        if ( pThisQueue->NumEntries < pThisQueue->QueueSize)
000006  7880              LDRB     r0,[r0,#2]
000008  7821              LDRB     r1,[r4,#0]
00000a  4288              CMP      r0,r1
00000c  d217              BCS      |L2.62|
;;;91        {  // save the new event, use % to create circular buffer in block
;;;92           // 1+ to step past the Queue struct at the beginning of the
;;;93           // block
;;;94           EnterCritical();   // save interrupt state, turn ints off
00000e  f7fffffe          BL       CPUgetPRIMASK_cpsid
000012  4601              MOV      r1,r0
000014  480b              LDR      r0,|L2.68|
;;;95           pBlock[ 1 + ((pThisQueue->CurrentIndex + pThisQueue->NumEntries)
000016  6001              STR      r1,[r0,#0]  ; _PRIMASK_temp
000018  7862              LDRB     r2,[r4,#1]
00001a  78a1              LDRB     r1,[r4,#2]
00001c  7823              LDRB     r3,[r4,#0]
00001e  440a              ADD      r2,r2,r1
000020  fbb2f1f3          UDIV     r1,r2,r3
000024  fb032211          MLS      r2,r3,r1,r2
000028  eb040182          ADD      r1,r4,r2,LSL #2
00002c  604d              STR      r5,[r1,#4]
;;;96                    % pThisQueue->QueueSize)] = Event2Add;
;;;97           pThisQueue->NumEntries++;          // inc number of entries
00002e  78a1              LDRB     r1,[r4,#2]
000030  1c49              ADDS     r1,r1,#1
000032  70a1              STRB     r1,[r4,#2]
;;;98           ExitCritical();  // restore saved interrupt state
000034  6800              LDR      r0,[r0,#0]  ; _PRIMASK_temp
000036  f7fffffe          BL       CPUsetPRIMASK
;;;99           
;;;100          return(true);
00003a  2001              MOVS     r0,#1
;;;101       }else
;;;102          return(false);
;;;103    }
00003c  bd70              POP      {r4-r6,pc}
                  |L2.62|
00003e  2000              MOVS     r0,#0                 ;102
000040  bd70              POP      {r4-r6,pc}
;;;104    
                          ENDP

000042  0000              DCW      0x0000
                  |L2.68|
                          DCD      ||.data||

                          AREA ||i.ES_EnQueueLIFO||, CODE, READONLY, ALIGN=2

                  ES_EnQueueLIFO PROC
;;;121    ****************************************************************************/
;;;122    bool ES_EnQueueLIFO( ES_Event * pBlock, ES_Event Event2Add )
000000  b570              PUSH     {r4-r6,lr}
;;;123    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;124       pQueue_t pThisQueue;
;;;125       pThisQueue = (pQueue_t)pBlock;
;;;126       // index will go from 0 to QueueSize-1 so use '<' to test if there is space
;;;127        if ( pThisQueue->NumEntries < pThisQueue->QueueSize){
000006  7880              LDRB     r0,[r0,#2]
000008  7821              LDRB     r1,[r4,#0]
00000a  4288              CMP      r0,r1
00000c  d217              BCS      |L3.62|
;;;128          EnterCritical();   // save interrupt state, turn ints off
00000e  f7fffffe          BL       CPUgetPRIMASK_cpsid
000012  490c              LDR      r1,|L3.68|
;;;129        // OK, there is space note that the queue now has 1 more entry
;;;130          pThisQueue->NumEntries++;
000014  6008              STR      r0,[r1,#0]  ; _PRIMASK_temp
000016  78a0              LDRB     r0,[r4,#2]
000018  1c40              ADDS     r0,r0,#1
00001a  70a0              STRB     r0,[r4,#2]
;;;131        // Check to see if we need to wrap around as we back up index
;;;132          if (pThisQueue->CurrentIndex == 0){
00001c  7862              LDRB     r2,[r4,#1]
00001e  b152              CBZ      r2,|L3.54|
000020  1e52              SUBS     r2,r2,#1
;;;133           pThisQueue->CurrentIndex = pThisQueue->QueueSize -1;
;;;134          }
;;;135          else{
;;;136            pThisQueue->CurrentIndex--;
000022  7062              STRB     r2,[r4,#1]
                  |L3.36|
;;;137          }  
;;;138          pBlock[ 1 + pThisQueue->CurrentIndex ] = Event2Add;
000024  7860              LDRB     r0,[r4,#1]
000026  eb040080          ADD      r0,r4,r0,LSL #2
00002a  6045              STR      r5,[r0,#4]
;;;139          ExitCritical();  // restore saved interrupt state      
00002c  6808              LDR      r0,[r1,#0]  ; _PRIMASK_temp
00002e  f7fffffe          BL       CPUsetPRIMASK
;;;140          return(true);
000032  2001              MOVS     r0,#1
;;;141        }else // in case no room on the queue
;;;142          return(false);
;;;143    }
000034  bd70              POP      {r4-r6,pc}
                  |L3.54|
000036  7820              LDRB     r0,[r4,#0]            ;133
000038  1e40              SUBS     r0,r0,#1              ;133
00003a  7060              STRB     r0,[r4,#1]            ;133
00003c  e7f2              B        |L3.36|
                  |L3.62|
00003e  2000              MOVS     r0,#0                 ;142
000040  bd70              POP      {r4-r6,pc}
;;;144    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      ||.data||

                          AREA ||i.ES_InitQueue||, CODE, READONLY, ALIGN=1

                  ES_InitQueue PROC
;;;57     ****************************************************************************/
;;;58     uint8_t ES_InitQueue( ES_Event * pBlock, uint8_t BlockSize )
000000  1e49              SUBS     r1,r1,#1
;;;59     {
;;;60        pQueue_t pThisQueue;
;;;61        // initialize the Queue by setting up initial values for elements
;;;62        pThisQueue = (pQueue_t)pBlock;
;;;63        // use all but the structure overhead as the Queue
;;;64        pThisQueue->QueueSize = BlockSize - 1;
000002  b2c9              UXTB     r1,r1
000004  7001              STRB     r1,[r0,#0]
;;;65        pThisQueue->CurrentIndex = 0;
000006  2200              MOVS     r2,#0
000008  7042              STRB     r2,[r0,#1]
;;;66        pThisQueue->NumEntries = 0;
00000a  7082              STRB     r2,[r0,#2]
;;;67        return(pThisQueue->QueueSize);
00000c  4608              MOV      r0,r1
;;;68     }
00000e  4770              BX       lr
;;;69     
                          ENDP


                          AREA ||i.ES_IsQueueEmpty||, CODE, READONLY, ALIGN=1

                  ES_IsQueueEmpty PROC
;;;201    ****************************************************************************/
;;;202    bool ES_IsQueueEmpty( ES_Event * pBlock )
000000  7880              LDRB     r0,[r0,#2]
;;;203    {
000002  b108              CBZ      r0,|L5.8|
;;;204       pQueue_t pThisQueue;
;;;205    
;;;206       pThisQueue = (pQueue_t)pBlock;
;;;207       return(pThisQueue->NumEntries == 0);
000004  2000              MOVS     r0,#0
;;;208    }
000006  4770              BX       lr
                  |L5.8|
000008  2001              MOVS     r0,#1                 ;207
00000a  4770              BX       lr
;;;209    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  _PRIMASK_temp
                          DCD      0x00000000
